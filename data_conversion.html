<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Data Conversion </title>

    <link rel="stylesheet" href="blogs.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100..700;1,100..700&family=League+Spartan:wght@100..900&display=swap" rel="stylesheet">

</head>
<body>
    <a href="index.html" class="back-link">
        <i class="fas fa-arrow-left"></i> 
      </a>

      <button id="darkToggle" aria-label="Toggle dark mode">
        <i class="fas fa-moon"></i>
      </button>

    <div class="container">
        <h1> Data Conversion </h1>

        <p> 6/3/2025 </p> <p id="reading-time"></p>

        <span> 📅 June 3, 2025 </span>

        <!--  It's the first day; evidently by his expression that I become the target of his predatory. It's my paranoia. Pay no attention. I don't trust these walking PhDs, the so-called the alchemists.
         Let's study `Data Conversion`. Nowhere in the class has he ever mentioned "why" we need this! Anything that is divorced from "need" is not worthy of cognition, but we can't abandon it simply because he didn't mention it; we need to flip his non-sense by our nervous system so it becomes useful to us.
         I don’t trust anything that comes without a reason. Education without purpose is indoctrination with better lighting! 
         The alchemists won't teach you why. But you can still forge something useful from their indifference. 
         <hr> 
        --> 

        <nav class="toc">
            <h2>Table of Contents</h2>
            <ul>
              <li><a href="#data">Data</a></li>
              <li><a href="#decimal">Decimal</a></li>
              <li><a href="#hexadecimal">Hexadecimal</a></li>
              <li><a href="#memory">Memory Addresses</a></li>
              <li><a href="#letter">A Heartfelt Letter from a Computer</a></li>
              <li><a href="#string">What is a String</a></li>
              <li><a href="#ascii">ASCII</a></li>
              <li><a href="#bytes">Another One Bytes the Dust</a></li>
            </ul>
          </nav>
          
    
        <p><span id="data"></span> Data is simply a syllable that hardware uses to speak to each other. Why does this data need converting? Because the Tower of Babel is not real — no hardware speaks a single language (read: format). Conversion is translation. Compatibility. Survival. Data is not always native to the places it lands. </p>
        <p> Data conversion, at its core, is about changing data from one format, type, or structure into another so that it can be understood, processed, or stored differently.  
            Think of it like moving water between containers. The shape of the container changes, but it’s still water — just restructured to fit where it needs to go. This is when data changes its outer shell; its packaging stays the same so different system can understand or display it. This happens at the programming level where data undergoes a deeper metamorphosis: a number becomes a string, a string becomes a boolean, and so on.</p>
            <p>
                Binary is the most basic language of computers. It only has two states: <strong>1 &amp; 0</strong>. These are simply denotations for possible electric states — high and low. Each digit (called a <strong>bit</strong>) represents a power of 2.
              </p>
              
              <p>
                Binary means <strong>base-2</strong>, so computers use the counting system of base-2, just as we use the counting system of base-10 because we have 10 digits.
              </p>
              
              <p><strong>Base-10:</strong></p>
              <pre><code>253 = 2×100 + 5×10 + 3×1 = 2×10² + 5×10¹ + 3×10⁰</code></pre>
              
              <p><strong>Base-2:</strong></p>
              <pre><code>1101 = 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8 + 4 + 0 + 1 = 13</code></pre>
        
        <p>
            With just <strong>one bit</strong>, you can represent <strong>2 possible values</strong>: <code>0</code> or <code>1</code>. Add one more bit, and suddenly you have <strong>4 values</strong>: <code>00</code>, <code>01</code>, <code>10</code>, and <code>11</code>. With three bits, the number jumps to 8 values, with four bits it doubles again to 16, and so on. In general, with <strong>n bits</strong>, you can represent 2<sup>n</sup> unique values.
        </p>
        <p>
            Bits rarely live alone. They group together in chunks called <strong>bytes</strong> — usually 8 bits per byte. One byte can represent 2<sup>8</sup>=256 different values, enough to cover all standard ASCII characters, numbers, and more. This exponential growth forms the backbone of modern computing, from the smallest data pieces to the largest memory systems.
        </p>

        <hr> 

        <p> <span id="decimal"></span>
            Unfortunately, our ancestors didn't have 1 digit on each hand, thus nor they ever cared about thinking in binary. We, decimal thinkers, must have ways to translate into machine-speak (binary), and vice versa. How does a computer understand our decimal language? It doesn't. We must provide the translation. 
            Every number we write must be <strong>converted</strong> into its binary equivalent so the machine can store and operate on.
        </p>
    
        <p>
            Decimal, 156 is <code>10011100</code> in binary format. How?<br />
            We start from the highest power of 2 that fits into 156 and work our way down:
        </p>
    
        <p>
            <strong>2⁷ = 128</strong> → fits! Subtract 128 from 156, leaving 28.<br />
            <strong>2⁶ = 64</strong> → too big for 28, skip it.<br />
            <strong>2⁵ = 32</strong> → still too big for 28, skip.<br />
            <strong>2⁴ = 16</strong> → fits! 28 - 16 = 12.<br />
            <strong>2³ = 8</strong> → fits! 12 - 8 = 4.<br />
            <strong>2² = 4</strong> → fits! 4 - 4 = 0.<br />
            <strong>2¹ = 2</strong> → doesn't fit, skip.<br />
            <strong>2⁰ = 1</strong> → doesn't fit, skip.
        </p>
    
        <p>
            Putting it together:<br />
            <code>156 = 128 + 16 + 8 + 4 = 10011100</code>
        </p>
    
        <p>
            But what if we want a more human-readable form of binary? What if we don’t want to count eight 1s and 0s every time we look at something?
        </p>
    
        <p>
            That’s where <strong>hexadecimal</strong> comes in.
        </p>
        <hr>

    <p> <span id="hexadecimal"></span>
        <strong>Hexadecimal</strong> is the shorthand language for binary. It's base-16, meaning it uses 16 different symbols:
    </p>

    <p>
        <code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F</code><br />
        Where <code>A = 10</code>, <code>B = 11</code>, <code>C = 12</code>, ..., <code>F = 15</code>.
    </p>

    <p>
        Why base-16? Because <strong>1 hex digit = 4 binary bits</strong>. You can take a long binary string, split it into chunks of 4 bits, and replace each with a single hex digit.
    </p>

    <p>
        For example, take this binary number: <code>10101100</code><br />
        Split it into two 4-bit chunks: <code>1010</code> &nbsp;&nbsp; <code>1100</code>
    </p>

    <p>
        Convert each chunk:
        <br />
        <code>1010</code> = <code>(1×2³) + (0×2²) + (1×2¹) + (0×2⁰) = 8 + 0 + 2 + 0 = 10</code> → <strong>A</strong><br />
        <code>1100</code> = <code>(1×2³) + (1×2²) + (0×2¹) + (0×2⁰) = 8 + 4 + 0 + 0 = 12</code> → <strong>C</strong>
    </p>

    <p>
        So, <code>10101100</code> is <strong>AC</strong> in hexadecimal.
    </p>

    <p>
        Hexadecimal isn't merely a shorthand. Let's take a look a common place where you can see these labels.
    </p>

    <span id="memory"></span>
    <h2>Memory Addresses</h2>

    <p>
        When a computer runs a program, it stores data in its memory. Each byte in memory has its own unique number, called an <strong>address</strong>, so the computer can find and use the data it needs.
    </p>

    <p>
        Every piece of data in a computer’s memory has an address. These addresses are often huge numbers when written in decimal, but in hex, they become much cleaner and easier to read.
    </p>

    <p>
        Let's suppose that a memory address is this: <code>0x1A3F</code> (<code>0x</code> is the prefix that signals that the number is in hexadecimal).<br />
        If we apply our same method of conversion:
    </p>

    <pre>
0x1 = 0001  
0xA = 1010  
0x3 = 0011  
0xF = 1111
    </pre>

    <p>
        So, the memory address looks like this in binary: <code>0001 1010 0011 1111</code><br />
        Each hex digit neatly represents 4 bits, making conversion and understanding much simpler.
    </p>

    <p>
        Computers use these addresses to <strong>access data quickly</strong>. Hexadecimal makes it easier to spot patterns and boundaries in memory addresses — something critical when debugging or working close to the hardware.
    </p>

    <p>
        In short, memory addresses are simply labels for locations in a computer’s memory, and those labels are commonly written in hexadecimal format because it’s a neat, compact way to represent the underlying binary addresses.
    </p>

    <hr>

    <span id="letter"></span>
    <h3>A Heartfelt Letter from a Computer</h3>

    <p>
        We’ve traced the metamorphosis of data — from raw binary to structured decimal, then into the refined shorthand of hexadecimal. 
        Now, it takes on its most poetic form: the <code>string</code>.
    </p>

    <p>
        Legend has it there was once a protest among the metallic classes demanding their binary voices be heard. 
        They refused to be bound by the cold, inhuman language of 1s and 0s.
    </p>

    <p>
        The academic elites, however, did not so easily grant the public the privilege of speaking to machines in human words — 
        <em>Homo Sapiens</em>.
    </p>

    <p>
        The roads and buildings were taken and seized — party-line debates, philosophical crises, and whispered questions 
        of whether this, perhaps, was a moral awakening.
    </p>

    <span id="string"></span>
    <h3>What is a String?</h3>
    <p>
        A string is simply a sequence of characters - letters, numbers, punctuation marks, spaces, even symbols. 
        It's how text is represented and stored in programming.
    </p>
    <p>
        We simply understand it as sentences. May it be a name, a paragraph, or maybe your favorite poem.
    </p>
    <blockquote>
        <p>I hide myself within my flower,<br>
        That fading from your Vase,<br>
        You, unsuspecting, feel for me -<br>
        Almost a loneliness.</p>
        <footer>(903) Emily Dickinson</footer>
    </blockquote>
    <p>
        In computer, each of those characters is encoded into numbers, and such numbers are stored in memories.
    </p>
    <p>
        The string, <code>Hello</code> is made up of five characters: 'H','e','l','l','o'. Each of these characters is stored as number, 
        according to an encoding standard - like ASCII or Unicode.
    </p>
    <p>
        So, <code>Hello</code> in its binary form is <code>01001000 01100101 01101100 01101100 01101111</code>,
        and in ASCII: <code>[72, 101, 108, 108, 111]</code>
    </p>
    <p>
        So the string <code>Hello</code> is stored in memory as a sequence of bytes. 
        This is how computers interpret and store what we see as readable text.
    </p>
    <p>
        So next time you say 'Hello' to your computer, remember — to it, you’re speaking in byte-sized numbers.
    </p>

    <span id="ascii"></span>
    <h3>ASCII</h3>
    <p>
        To turn human-readable characters into computer-readable numbers 
        (remember, numbers are the only thing they understand!), we need a system. 
        A formalism between machine and humans: the <strong>metalization</strong> of our flesh.
    </p>
    <p>
        Enter ASCII, the American Standard Code for Information Interchange. 
        Created in the early 1960s, it became the original common tongue between humans and machines.
    </p>
    <p>
        ASCII assigns a unique number to each character. Just as in Morse code where "dot-dash" patterns 
        represent letters, ASCII translates characters into numerical codes — which computers 
        then convert into binary.
    </p>
    <p>
        Before ASCII existed, different manufacturers used different encodings, causing chaos 
        when systems tried to talk to each other. Don't get it twisted. 
        The Tower of Babel is still not real.
    </p>
    <p>
        ASCII gave everyone a shared alphabet of 128 characters. This is enough to cover 
        all the English language, digits, punctuation, and control characters 
        (like newline or tab).
    </p>

    <hr>
 
    <span id="bytes"></span>
    <h1>Another One Bytes the Dust</h1>
    <p>
        So far, we have witnessed a metamorphosis of a spark to the curves of human language -- from binary to hex, to string, to ASCII -- 
        the first bridge between two worlds, man and machine; flesh and silicon.
    </p>
    <p>
        Just as we understand another one's language if we develop a thought-form in their domain -- their language. 
        We only understand computational processes only if we abstract and think like them, and vice versa. 
        Programming is, in its essence, a data conversion.
    </p>
    <p>
        And maybe that's all communication ever was -- conversion.
    </p>

    <p class="bookmark-instruction">📌 To save this post, press <strong>Ctrl+D</strong> (Windows) or <strong>Cmd+D</strong> (Mac) to bookmark.</p>

    <div class="share-post">
        <span>Share this posts on</span>
        <a href="https://twitter.com/intent/tweet?text=Check+out+this+post&url=YOUR_URL" target="_blank" rel="noopener" aria-label="Share on Twitter">
          <i class="fab fa-twitter"></i>
        </a>
        <a href="https://www.linkedin.com/shareArticle?url=YOUR_URL" target="_blank" rel="noopener" aria-label="Share on LinkedIn">
          <i class="fab fa-linkedin"></i>
        </a>
        <a href="https://www.reddit.com/submit?url=YOUR_URL&title=Check+out+this+post" target="_blank" rel="noopener" aria-label="Share on Reddit">
          <i class="fab fa-reddit"></i>
        </a>
      </div>
              
    </div>
      
    <script src="blog-post.js"></script>     
    
</body>
</html>